<?php

declare(strict_types=1);

namespace DIJ\ApiFactories;

use Closure;
use Faker\Generator;
use Illuminate\Container\Container;
use Illuminate\Contracts\Container\BindingResolutionException;
use Illuminate\Database\Eloquent\Factories\Sequence;
use Illuminate\Support\Collection;
use Illuminate\Support\Traits\ForwardsCalls;
use Illuminate\Support\Traits\Macroable;

abstract class ApiFactory
{
    use ForwardsCalls, Macroable {
        __call as macroCall;
    }

    /**
     * The number of models that should be generated.
     *
     * @var int|null
     */
    protected ?int $count;

    /**
     * The state transformations that will be applied to the model.
     *
     * @var Collection
     */
    protected Collection $states;

    /**
     * The "after making" callbacks that will be applied to the model.
     *
     * @var Collection
     */
    protected Collection $afterMaking;

    /**
     * The current Faker instance.
     *
     * @var Generator
     */
    protected Generator $faker;

    /**
     * Create a new factory instance.
     *
     * @param int|null $count
     * @param Collection|null $states
     * @param Collection|null $afterMaking
     * @throws BindingResolutionException
     */
    public function __construct(
        ?int $count = null,
        ?Collection $states = null,
        ?Collection $afterMaking = null
    ) {
        $this->count = $count;
        $this->states = $states ?: new Collection;
        $this->afterMaking = $afterMaking ?: new Collection;
        $this->faker = $this->withFaker();
    }

    /**
     * Define the model's default state.
     *
     * @return array
     */
    abstract public function definition(): array;

    /**
     * Get a new factory instance for the given attributes.
     *
     * @param callable|array $attributes
     * @return static
     */
    public static function new($attributes = []): self
    {
        return (new static)->state($attributes)->configure();
    }

    /**
     * Get a new factory instance for the given number of models.
     *
     * @param int $count
     * @return static
     */
    public static function times(int $count): self
    {
        return static::new()->count($count);
    }

    /**
     * Configure the factory.
     *
     * @return $this
     */
    public function configure(): self
    {
        return $this;
    }

    /**
     * Get the raw attributes generated by the factory.
     *
     * @param array $attributes
     * @return array
     */
    public function raw(array $attributes = []): array
    {
        if ($this->count === null) {
            return $this->state($attributes)->getExpandedAttributes();
        }

        return array_map(
            fn ($_) => $this->state($attributes)->getExpandedAttributes(),
            range(1, $this->count)
        );
    }

    /**
     * Make a single instance of the model.
     *
     * @param callable|array $attributes
     * @return array<string,mixed>
     */
    public function makeOne($attributes = []): array
    {
        return $this->count(null)->make($attributes);
    }

    /**
     * Create a collection of models.
     *
     * @param array $attributes
     * @return Collection|array<string,mixed>|mixed
     */
    public function make(array $attributes = [])
    {
        if (! empty($attributes)) {
            return $this->state($attributes)->make([]);
        }

        if ($this->count === null) {
            return tap(
                $this->makeInstance(),
                function ($instance) {
                    $this->callAfterMaking(collect([$instance]));
                }
            );
        }

        if ($this->count < 1) {
            return new Collection();
        }

        $instances = new Collection(
            array_map(
                fn ($_) => $this->makeInstance(),
                range(1, $this->count)
            )
        );

        $this->callAfterMaking($instances);

        return $instances;
    }

    public function json(array $attributes = [])
    {
        return json_encode($this->make($attributes));
    }

    /**
     * Make an instance of the model with the given attributes.
     *
     * @return array<string,mixed>
     */
    protected function makeInstance(): array
    {
        return $this->getExpandedAttributes();
    }

    /**
     * Get a raw attributes array for the model.
     *
     * @return array<string,mixed>
     */
    protected function getExpandedAttributes(): array
    {
        return $this->expandAttributes($this->getRawAttributes());
    }

    /**
     * Get the raw attributes for the model as an array.
     *
     * @return array<string,mixed>
     */
    protected function getRawAttributes(): array
    {
        return $this->states->pipe(
            function ($states) {
                return $states;
            }
        )->reduce(
            function ($carry, $state) {
                if ($state instanceof Closure) {
                    $state = $state->bindTo($this);
                }

                return array_merge($carry, $state($carry));
            },
            $this->definition()
        );
    }

    /**
     * Expand all attributes to their underlying values.
     *
     * @param array $definition
     * @return array<string,mixed>
     */
    protected function expandAttributes(array $definition): array
    {
        return collect($definition)->map(
            function ($attribute, $key) use (&$definition) {
                if (is_callable($attribute) && ! is_string($attribute) && ! is_array($attribute)) {
                    $attribute = $attribute($definition);
                }
                if ($attribute instanceof self) {
                    $attribute = $attribute->make();
                }

                $definition[$key] = $attribute;

                return $attribute;
            }
        )->all();
    }

    /**
     * Add a new state transformation to the model definition.
     *
     * @param callable|array $state
     * @return static
     */
    public function state($state): self
    {
        return $this->newInstance(
            [
                'states' => $this->states->concat(
                    [
                        is_callable($state) ? $state : function () use ($state) {
                            return $state;
                        },
                    ]
                ),
            ]
        );
    }

    /**
     * Add a new sequenced state transformation to the model definition.
     *
     * @param array<Sequence> $sequence
     * @return static
     */
    public function sequence(...$sequence): self
    {
        return $this->state(new Sequence(...$sequence));
    }

    /**
     * Add a new "after making" callback to the model definition.
     *
     * @param Closure $callback
     * @return static
     */
    public function afterMaking(Closure $callback): self
    {
        return $this->newInstance(['afterMaking' => $this->afterMaking->concat([$callback])]);
    }

    /**
     * Call the "after making" callbacks for the given model instances.
     *
     * @param Collection $instances
     * @return void
     */
    protected function callAfterMaking(Collection $instances): void
    {
        $instances->each(
            function ($model) {
                $this->afterMaking->each(
                    function ($callback) use ($model) {
                        $callback($model);
                    }
                );
            }
        );
    }

    /**
     * Specify how many models should be generated.
     *
     * @param int|null $count
     * @return static
     */
    public function count(?int $count)
    {
        return $this->newInstance(['count' => $count]);
    }

    /**
     * Create a new instance of the factory builder with the given mutated properties.
     *
     * @param array $arguments
     * @return static
     */
    protected function newInstance(array $arguments = []): self
    {
        return new static(
            ...array_values(
                array_merge(
                    [
                        'count' => $this->count,
                        'states' => $this->states,
                        'afterMaking' => $this->afterMaking,
                    ],
                    $arguments
                )
            )
        );
    }

    /**
     * Get a new Faker instance.
     *
     * @return Generator
     * @throws BindingResolutionException
     */
    protected function withFaker(): Generator
    {
        return Container::getInstance()->make(Generator::class);
    }

    /**
     * Proxy dynamic factory methods onto their proper methods.
     *
     * @param string $method
     * @param array $parameters
     * @return mixed
     */
    public function __call($method, $parameters)
    {
        if (static::hasMacro($method)) {
            return $this->macroCall($method, $parameters);
        }
    }
}
